快速·多项式模板
```c++
#include<bits/stdc++.h>  
namespace stdpoly{  
struct complex{  
double x,y;  
void operator=(int t){x=t>>15,y=t&32767;}  
complex operator+(complex t){return {x+t.x,y+t.y};}  
complex operator-(complex t){return {x-t.x,y-t.y};}  
complex operator*(complex t){return {x*t.x-y*t.y,x*t.y+y*t.x};}  
complex operator*(double t){return {x*t,y*t};}  
complex operator~(){return {x,-y};}  
};  
struct poly{  
int* data;int len;  
poly(int* data,int len=0):data(data),len(len){}  
int& operator[](const int x){return data[x];}  
const int& operator[](const int x)const{return data[x];}  
poly operator=(poly a){  
memcpy(data,a.data,sizeof(int)*a.len);  
len=a.len;return *this;  
}  
poly resize(int n){return {data,n};}  
};  
#define range(p) p.data,p.data+p.len  
class _poly_base{  
protected:  
static const size_t N=4e6+10;  
int MOD,limit,rev[N];  
void InitLimit(const int _limit){  
if(limit>=_limit) return;  
limit=1<<(int)ceil(log2(_limit));  
for(int i=0;i<limit;i++) rev[i]=rev[i>>1]>>1|(i&1?limit>>1:0);  
InitLimitExtra();  
}  
virtual void InitLimitExtra()=0;  
int qpow(int a,int b){  
int ret=1;  
while(b){  
if(b&1) ret=1ll*ret*a%MOD;  
a=1ll*a*a%MOD;b>>=1;  
}  
return ret;  
}  
public:  
void SetMod(int p){MOD=p;}  
virtual void mul(poly,poly,poly)=0;  
void mul_eq(poly a,poly b){mul(a,a,b);}  
poly neg(poly a){  
for(int i=0;i<a.len;i++) a[i]=MOD-a[i];  
return a;  
}  
poly pls(poly a,int b){  
a[0]=(a[0]+b)%MOD;  
return a;  
}  
};  
class FFT:public _poly_base{  
complex w[N];  
protected:  
void InitLimitExtra(){  
static const double PI=acos(-1);  
for(int m=1;m<limit;m<<=1){  
w[m]={1,0};  
for(int i=1;i<m;i++){  
if((i&31)==1) w[i+m]={cos(PI*i/m),sin(PI*i/m)};  
else w[i+m]=w[i+m-1]*w[m+1];  
}  
}  
}  
void T(complex *val,const int type){  
if(type==-1) std::reverse(val+1,val+limit);  
for(int i=0;i<limit;i++) if(i<rev[i]) std::swap(val[i],val[rev[i]]);  
for(int m=1;m<limit;m<<=1){  
for(int i=0;i<limit;i+=m<<1){  
for(int j=0;j<m;j++){  
complex t=w[m+j]*val[i+m+j];  
val[i+m+j]=val[i+j]-t;  
val[i+j]=val[i+j]+t;  
}  
}  
}  
}  
};  
class NTT:public _poly_base{  
int w[N],tmp_a[N],tmp_b[N],tmp_c[N];  
protected:  
void InitLimitExtra(){  
static const double PI=acos(-1);  
for(int m=1;m<limit;m<<=1){  
w[m]=1;  
for(int i=1;i<m;i++){  
if(i==1) w[i+m]=qpow(3,(MOD-1)/(m<<1));  
else w[i+m]=1ll*w[i+m-1]*w[m+1]%MOD;  
}  
}  
}  
int chk(int a){return a>MOD?a-MOD:a;}  
void T(int *val,const int type){  
for(int i=0;i<limit;i++) if(i<rev[i]) std::swap(val[i],val[rev[i]]);  
for(int m=1;m<limit;m<<=1){  
for(int i=0;i<limit;i+=m<<1){  
for(int j=0;j<m;j++){  
int t=1ll*w[m+j]*val[i+m+j]%MOD;  
val[i+m+j]=chk(val[i+j]-t+MOD);  
val[i+j]=chk(val[i+j]+t);  
}  
}  
}  
if(type==-1){  
std::reverse(val+1,val+limit);  
int inv=qpow(limit,MOD-2);  
for(int i=0;i<limit;i++) val[i]=1ll*val[i]*inv%MOD;  
}  
}  
public:  
void mul(poly c,poly a,poly b){  
int n=a.len+b.len-1;  
InitLimit(n);  
std::fill(tmp_a,tmp_a+limit,0);  
std::fill(tmp_b,tmp_b+limit,0);  
std::copy(range(a),tmp_a);  
std::copy(range(b),tmp_b);  
T(tmp_a,1);T(tmp_b,1);  
for(int i=0;i<limit;i++) tmp_c[i]=1ll*tmp_a[i]*tmp_b[i]%MOD;  
T(tmp_c,-1);  
std::copy(tmp_c,tmp_c+c.len,c.data);  
}  
};  
class MTT:public FFT{  
complex tmp_a[N],tmp_b[N],tmp_c[N],tmp_d[N];  
public:  
void mul(poly c,poly a,poly b){  
int n=a.len+b.len-1;  
InitLimit(n);  
std::fill(tmp_a,tmp_a+limit,0);  
std::fill(tmp_b,tmp_b+limit,0);  
std::copy(range(a),tmp_a);  
std::copy(range(b),tmp_b);  
T(tmp_a,1);T(tmp_b,1);  
for(int i=0;i<limit;i++){  
complex ft=~tmp_a[i?limit-i:0],  
f0=(tmp_a[i]-ft)*complex{0,-0.5},  
f1=(tmp_a[i]+ft)*0.5;  
complex gt=~tmp_b[i?limit-i:0],  
g0=(tmp_b[i]-gt)*complex{0,-0.5},  
g1=(tmp_b[i]+gt)*0.5;  
tmp_c[i]=f1*g1,tmp_d[i]=f0*g1+f1*g0+f0*g0*complex{0,1};  
}  
std::fill(tmp_a,tmp_a+limit,0);  
std::fill(tmp_b,tmp_b+limit,0);  
T(tmp_c,-1),T(tmp_d,-1);  
using ll=long long;  
for(int i=0;i<c.len;i++){  
ll v1=(ll)(tmp_c[i].x/limit+0.5)%MOD,  
v2=(ll)(tmp_d[i].x/limit+0.5)%MOD,  
v3=(ll)(tmp_d[i].y/limit+0.5)%MOD;  
c[i]=((v1<<30)+(v2<<15)+v3)%MOD;  
tmp_c[i]=0,tmp_d[i]=0;  
}  
}  
};  
template<typename _Tp>  
class calculate:public _Tp{  
using _Tp::InitLimit;  
using _Tp::limit;  
using _Tp::N;  
using _Tp::MOD;  
using _Tp::mul;  
using _Tp::mul_eq;  
using _Tp::pls;  
using _Tp::neg;  
using _Tp::qpow;  
public:  
using _Tp::SetMod;  
void inv(poly b,poly a){  
static int tmp[N],tmp_b[N];  
InitLimit(a.len);int _lim=limit;  
tmp_b[0]=qpow(a[0],MOD-2);  
for(int n=2;n<=_lim;n<<=1){  
mul({tmp,n},a.resize(n),{tmp_b,n>>1});  
mul_eq({tmp_b,n},pls(neg({tmp,n}),2));  
}  
std::copy(tmp_b,tmp_b+b.len,b.data);  
}  
};  
template<typename _Tp>  
class combinatorics:public calculate<_Tp>{  
using _Tp::N;  
using _Tp::limit;  
using _Tp::MOD;  
int fact[N];  
protected:  
void InitLimitExtra(){  
fact[0]=1;for(int i=1;i<=limit;i++) fact[i]=1ll*fact[i-1]*i%MOD;  
}  
};  
class BM:public _poly_base{  
int _lst[N],_tmp[N],_ans[N];  
public:  
void berlekamp_massey(poly& b,poly a){  
poly lst(_lst,0),ans(_ans,0);ans.len=0;  
int k,invdeltak,lv=-1;  
for(int i=0;i<a.len;i++){  
int delta=a[i];  
for(int j=0;j<ans.len;j++)  
delta=(delta+MOD-1ll*a[i-1-j]*ans[j]%MOD)%MOD;  
if(delta==0) continue;  
poly tmp=ans;  
if(ans.len==0) for(int j=0;j<=i;j++) ans[ans.len++]=0;  
else{  
int tmp=1ll*delta*invdeltak%MOD;  
if(ans.len<i-k+lst.len) ans.len=i-k+lst.len;  
(ans[i-k-1]+=tmp)%=MOD;  
for(int j=0;j<lst.len;j++)  
(ans[i-k+j]+=1ll*(MOD-tmp)*lst[j]%MOD)%=MOD;  
}  
if(i-tmp.len>lv) lv=i-tmp.len,lst=tmp,invdeltak=qpow(delta,MOD-2),k=i;  
}  
b=ans;  
}  
};  
}  
class Main:stdpoly::NTT{  
public:  
const static int N=2e6+10;  
int a[N],b[N],c[N];  
void main(){  
using namespace stdpoly;  
int n,m;scanf("%d%d",&n,&m);  
SetMod(998244353);  
for(int i=0;i<=n;i++) scanf("%d",a+i);  
for(int i=0;i<=m;i++) scanf("%d",b+i);  
mul(poly(c,n+m+1),poly(a,n+1),poly(b,m+1));  
for(int i=0;i<=n+m;i++) printf("%d ",c[i]);  
}  
};  
Main M;int main(){M.main();}//OOP
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM0ODY4OTUzNl19
-->