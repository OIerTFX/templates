快速·多项式模板
```c++
#include<bits/stdc++.h>
namespace stdpoly{
#define INT_S sizeof(int)
	struct complex{
		double x,y;
		void operator=(int t){x=t>>15,y=t&32767;}
		complex operator+(complex t){return {x+t.x,y+t.y};}
		complex operator-(complex t){return {x-t.x,y-t.y};}
		complex operator*(complex t){return {x*t.x-y*t.y,x*t.y+y*t.x};}
		complex operator*(double t){return {x*t,y*t};}
		complex operator~(){return {x,-y};}
	};
	struct poly{
		int* data;int len;
		poly(int* data,int len=0):data(data),len(len){}
		int& operator[](const int x){return data[x];}
		const int& operator[](const int x)const{return data[x];}
		poly cut(int n){return {data,std::min(len,n)};}
		poly resize(int n){
			if(n>len) memset(data+len,0,INT_S*(n-len));
			return {data,len=n};
		}
		poly operator<<(poly a)const{
			if(data!=a.data) memcpy(data,a.data,INT_S*std::min(len,a.len));
			memset(data+std::min(len,a.len),0,INT_S*std::max(len-a.len,0));
			return *this;
		}
		poly operator<<=(poly a){
			len=a.len;
			memcpy(data,a.data,INT_S*len);
			return *this;
		}
	};
#define range(p) p.data,p.data+p.len
	class _poly_base{
	protected:
		static const size_t N=4e6+10;
		int MOD,limit,rev[N];
		void InitLimit(const int _limit){
			limit=1<<(int)ceil(log2(_limit));
			for(int i=0;i<limit;i++) rev[i]=rev[i>>1]>>1|(i&1?limit>>1:0);
			InitLimitExtra();
		}
		virtual void InitLimitExtra()=0;
		int qpow(int a,int b){
			int ret=1;
			while(b){
				if(b&1) ret=1ll*ret*a%MOD;
				a=1ll*a*a%MOD;b>>=1;
			}
			return ret;
		}
		int chk(int a){return a>MOD?a-MOD:a;}
	public:
		void SetMod(int p){MOD=p;}
		virtual poly mul(poly,poly,poly)=0;
		poly mul_eq(poly a,poly b){return mul(a,a,b);}
		poly neg(poly a){
			for(int i=0;i<a.len;i++) a[i]=MOD-a[i];
			return a;
		}
		poly pls(poly a,int b){
			a[0]=chk(a[0]+b);
			return a;
		}
	};
	class FFT:public _poly_base{
		complex w[N];
	protected:
		void InitLimitExtra(){
			static const double PI=acos(-1);
			for(int m=1;m<limit;m<<=1){
				w[m]={1,0};
				for(int i=1;i<m;i++){
					if((i&31)==1) w[i+m]={cos(PI*i/m),sin(PI*i/m)};
					else w[i+m]=w[i+m-1]*w[m+1];
				}
			}
		}
		void T(complex *val,const int type){
			if(type==-1) std::reverse(val+1,val+limit);
			for(int i=0;i<limit;i++) if(i<rev[i]) std::swap(val[i],val[rev[i]]);
			for(int m=1;m<limit;m<<=1){
				for(int i=0;i<limit;i+=m<<1){
					for(int j=0;j<m;j++){
						complex t=w[m+j]*val[i+m+j];
						val[i+m+j]=val[i+j]-t;
						val[i+j]=val[i+j]+t;
					}
				}
			}
		}
	};
	class MTT:public FFT{
		complex tmp_a[N],tmp_b[N],tmp_c[N],tmp_d[N];
	public:
		poly mul(poly c,poly a,poly b){
			InitLimit(a.len+b.len-1);
			std::fill(tmp_a,tmp_a+limit,0);
			std::fill(tmp_b,tmp_b+limit,0);
			std::copy(range(a),tmp_a);
			std::copy(range(b),tmp_b);
			T(tmp_a,1);T(tmp_b,1);
			for(int i=0;i<limit;i++){
				complex ft=~tmp_a[i?limit-i:0],
				f0=(tmp_a[i]-ft)*complex{0,-0.5},
				f1=(tmp_a[i]+ft)*0.5;
				complex gt=~tmp_b[i?limit-i:0],
				g0=(tmp_b[i]-gt)*complex{0,-0.5},
				g1=(tmp_b[i]+gt)*0.5;
				tmp_c[i]=f1*g1,tmp_d[i]=f0*g1+f1*g0+f0*g0*complex{0,1};
			}
			std::fill(tmp_a,tmp_a+limit,0);
			std::fill(tmp_b,tmp_b+limit,0);
			T(tmp_c,-1),T(tmp_d,-1);
			using ll=long long;
			for(int i=0;i<c.len&&i<limit;i++){
				ll v1=(ll)(tmp_c[i].x/limit+0.5)%MOD,
				v2=(ll)(tmp_d[i].x/limit+0.5)%MOD,
				v3=(ll)(tmp_d[i].y/limit+0.5)%MOD;
				c[i]=((v1<<30)+(v2<<15)+v3)%MOD;
				tmp_c[i]=0,tmp_d[i]=0;
			}
			for(int i=limit;i<c.len;i++) c[i]=0;
			return c;
		}
	};
	class NTT:public _poly_base{
		int w[N],tmp_a[N],tmp_b[N],tmp_c[N];
	protected:
		void InitLimitExtra(){
			static const double PI=acos(-1);
			for(int m=1;m<limit;m<<=1){
				w[m]=1;
				for(int i=1;i<m;i++){
					if(i==1) w[i+m]=qpow(3,(MOD-1)/(m<<1));
					else w[i+m]=1ll*w[i+m-1]*w[m+1]%MOD;
				}
			}
		}
		void T(int *val,const int type){
			for(int i=0;i<limit;i++) if(i<rev[i]) std::swap(val[i],val[rev[i]]);
			for(int m=1;m<limit;m<<=1){
				for(int i=0;i<limit;i+=m<<1){
					for(int j=0;j<m;j++){
						int t=1ll*w[m+j]*val[i+m+j]%MOD;
						val[i+m+j]=chk(val[i+j]-t+MOD);
						val[i+j]=chk(val[i+j]+t);
					}
				}
			}
			if(type==-1){
				std::reverse(val+1,val+limit);
				int inv=qpow(limit,MOD-2);
				for(int i=0;i<limit;i++) val[i]=1ll*val[i]*inv%MOD;
			}
		}
	public:
		poly mul(poly c,poly a,poly b){
			InitLimit(a.len+b.len-1);
			poly(tmp_a,limit)<<a,
			poly(tmp_b,limit)<<b;
			T(tmp_a,1);T(tmp_b,1);
			for(int i=0;i<limit;i++) tmp_c[i]=1ll*tmp_a[i]*tmp_b[i]%MOD;
			T(tmp_c,-1);return c<<poly(tmp_c,limit);
		}
	};
	template<typename _Tp>
	class calculate:public _Tp{
		using _Tp::N;
		using _Tp::MOD;
		using _Tp::mul;
		using _Tp::mul_eq;
		using _Tp::pls;
		using _Tp::neg;
		using _Tp::qpow;
		using _Tp::chk;
	public:
		poly inv(poly b,poly a){
			static int tmp[N],tmp_b[N];
			tmp_b[0]=qpow(a[0],MOD-2);
			for(int n=2;n/2<b.len;n<<=1)
				mul({tmp_b,n},{tmp_b,n/2},pls(neg(mul({tmp,n},a.cut(n),{tmp_b,n/2})),2));
			return b<<poly(tmp_b,b.len);
		}
		poly inv_eq(poly a){return inv(a,a);}
		poly diff(poly b,poly a){
			for(int i=0;i<b.len;i++)
				b[i]=i+1<a.len?1ll*a[i+1]*(i+1)%MOD:0;
			return b;
		}
		poly inte(poly b,poly a){
			for(int i=b.len-1;i>=1;i--)
				b[i]=i-1<a.len?1ll*a[i-1]*qpow(i,MOD-2)%MOD:0;
			b[0]=0;return b;
		}
		poly plus_eq(poly b,poly a){
			for(int i=0;i<b.len&&i<a.len;i++) b[i]=chk(b[i]+a[i]);
			return b;
		}
		poly ln(poly b,poly a){
			static int tmp[N],tmp_b[N];
			return inte(b,mul_eq(diff({tmp_b,b.len},a),inv({tmp,b.len},a)));
		}
		poly exp(poly b,poly a){
			static int tmp[N],tmp_b[N];
			tmp_b[0]=1;
			for(int n=2;n/2<b.len;n<<=1)
				mul({tmp_b,n},{tmp_b,n/2},plus_eq(pls(neg(ln({tmp,n},{tmp_b,n/2})),1),a.cut(n)));
			return b<<poly(tmp_b,b.len);
		}
		poly euler(poly b,poly a){
			static int tmp_a[N];
			for(int n=1;n<a.len;n++){
				int invn=qpow(n,MOD-2);
				for(int i=0;i*n<a.len;i++)
					tmp_a[n*i]=chk(tmp_a[n*i]+1ll*a[i]*invn%MOD);
			}
			return exp(b,{tmp_a,a.len});
		}
		poly rev(poly b,poly a){
			for(int i=0;i<=a.len-i-1;i++){
				int x=a[i],y=a[a.len-i-1];
				if(i<b.len) b[i]=y;
				if(a.len-i-1<b.len) b[a.len-i-1]=x;
			}
			if(b.len>a.len) memset(b.data+a.len,0,INT_S*(b.len-a.len));
			return b;
		}
		poly rev_eq(poly a){return rev(a,a);}
		poly div(poly c,poly a,poly b){
			int n=a.len-b.len+1;static int _a[N],_b[N];
			return rev_eq(mul({c.data,n},rev({_a,n},a),inv_eq(rev({_b,n},b))));
		}
		poly div_eq(poly b,poly a){return div(b,b,a);}
		poly minus(poly c,poly a,poly b){
			for(int i=0;i<c.len&&i<a.len&&i<b.len;i++) c[i]=chk(a[i]+MOD-b[i]);
			for(int i=a.len;i<c.len;i++) c[i]=MOD-b[i];
			for(int i=b.len;i<c.len;i++) c[i]=a[i];
			return c;
		}
		poly mod(poly c,poly a,poly b){
			if(a.len<b.len) return c<<=a;
			static int _tmp[N];poly(_tmp)<<=a;
			return minus({c.data,b.len-1},a,mul_eq(div_eq({_tmp,a.len},b).resize(b.len-1),b));
		}
		poly mod_eq(poly b,poly a){return mod(b,b,a);}
		/*int recurrence(poly f,poly a,int n){
			static int tmp_g[N],tmp_b[N];
			neg(rev_eq(f));f[f.len++]=1;
			poly g(tmp_g,2),b(tmp_b,1);
			g[0]=0,g[1]=1,b[0]=1;
			while(n){
				if(n&1) mod_eq(mul_eq(b.resize(b.len+g.len-1),g),f);
				mod_eq(mul_eq(g.resize(g.len+g.len-1),g),f);n>>=1;
			}
			int ret=0;
			for(int i=0;i<b.len;i++) ret=chk(ret+1ll*a[i]*b[i]%MOD);
			return ret;
		}
		poly berlekamp_massey(poly b,poly a){
			static int _lst[N],_tmp[N],_ans[N];
			poly lst(_lst),ans(_ans);
			int k,invdeltak,lv=-1;
			for(int i=0;i<a.len;i++){
				int delta=a[i];
				for(int j=0;j<ans.len;j++)
					delta=chk(delta+MOD-1ll*a[i-1-j]*ans[j]%MOD);
				if(delta==0) continue;
				poly tmp(_tmp);tmp<<=ans;
				if(ans.len==0) ans.resize(ans.len+i+1);
				else{
					int tmp=1ll*delta*invdeltak%MOD;
					if(ans.len<i-k+lst.len) ans.resize(i-k+lst.len);
					(ans[i-k-1]+=tmp)%=MOD;
					for(int j=0;j<lst.len;j++)
						(ans[i-k+j]+=1ll*(MOD-tmp)*lst[j]%MOD)%=MOD;
				}
				if(i-tmp.len>lv) lv=i-tmp.len,lst<<=tmp,invdeltak=qpow(delta,MOD-2),k=i;
			}
			return b<<=ans;
		}*/
	};
	template<typename _Tp>
	class combinatorics:public calculate<_Tp>{
		using _Tp::N;
		using _Tp::limit;
		using _Tp::MOD;
		int fact[N];
	protected:
		void InitLimitExtra(){
			fact[0]=1;for(int i=1;i<=limit;i++) fact[i]=1ll*fact[i-1]*i%MOD;
		}
	};
#undef INT_S
#undef range
}
class Main:stdpoly::calculate<stdpoly::NTT>{
public:
	const static int N=2e6+10;
	int p[N],f[N];
	void main(){
		using namespace stdpoly;
	}
}M;
int main(){M.main();}//OOP
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjYyMjQ0ODAsNzA3NzQ4MzkwLDEzNDg2OD
k1MzZdfQ==
-->
